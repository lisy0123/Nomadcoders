# Clean Code

## 목차

>  [0. 추천사 & 들어가면서](https://github.com/lisy0123/Nomadcoders/tree/main/Clean_Code#0-%EC%B6%94%EC%B2%9C%EC%82%AC--%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B4%EC%84%9C)
>
> [1. 깨끗한 코드](https://github.com/lisy0123/Nomadcoders/tree/main/Clean_Code#1-%EA%B9%A8%EB%81%97%ED%95%9C-%EC%BD%94%EB%93%9C)

## 0. 추천사 & 들어가면서

### 기억하고 싶은 책 내용

- 사소한 곳에서 발휘하는 정직은 사소하지 않다: 단순히 사소한 것에 집중할 뿐 아니라 사소한 것에 정직해야 한다는 의미
- 신은 세세함에 깃들어 있다. - 루트비히 미스 반 데어 로에, 건축가
- 5S 원칙: 정리(Seiri, 정렬), 정돈(Seiton, 체계화), 청소(Seiso, 광내기), 청결(Seiketsu, 표준화), 생활화(Shutsuke, 규율)
- 작은 것에도 충실한 사람이 큰 것에도 충실하다.
- 품질은 하늘에서 뚝 떨어진 위대한 방법론이 아니라 사심 없이 기울이는 무수한 관심에서 얻어진다.
- 장인 정신: 이론 + 실전

### 소감 및 생각

클린코드는 코드를 짤 때마다 항상 따라오는 말이다. 42SV를 다니면서 그 중요성을 처음 알았고, 팀플을 하면서 클린코드의 중요성을 다시 한 번 느낄 수 있었다. 내 코드는 얼마나 꺠끗한지 되돌아보면서 내 코드 작성 습관을 다듬는데 좋은 지침서가 되어줄 것 같다.

### 새롭게 배운 개념

- [애자일](http://www.incodom.kr/%EC%95%A0%EC%9E%90%EC%9D%BC_%EB%B0%A9%EB%B2%95%EB%A1%A0): 개인별 또는 팀 간에 고객과 협업하고 빠른 개발을 수행(고객과 협업)
- [린(Lean)](http://www.incodom.kr/%EB%A6%B0_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0): 고객 관점에서 전체 프로세스상에서 낭비를 제거하여 고객 가치를 높이는 것에 우선순위(전적으로 고객 관점)

---

## 1. 깨끗한 코드

### 기억하고 싶은 책 내용

- 코드는 요구사항을 표현하는 언어라는 사실을 명심한다. (p.3)
- 나중은 결코 오지 않는다. (p.4)
- 좋은 코드를 사수하는 일은 바로 우리 프로그래머들의 책임이다. (p.7)
- 깨끗한 코드를 작성하는 프로그래머는 빈 캔퍼스를 우아한 작품으로 바꿔가는 화가와 같다. (p. 8)
- 나쁜 코드는 나쁜 코드를 유혹한다. (p.9)
- 꺠끗한 코드는 세세한 사항까지 꼼꼼하게 처리하는 코드이다. (p.10)
- 깨끗한 코드는 한가지에 집중한다. (P.10)
- 아우리 코드가 우아해도, 아무리 가독성이 높아도, 테스트 케이스가 없으면 깨끗하지 않다. (p.12)
- 깨끗한 코드는 주의 깊게 작성한 코드다. (p.12)
- 중복 줄이기, 표현력 높이기. 초반부터 간단한 추상화 고려하기 (p.14)

### 소감 및 생각

나쁜 코드를 클린 코드를 바꾸는 법에 대해 알려준다는 말이 가장 눈에 띄었다. 42SV에서 만든 코드 작성 습관과 책의 내용과 비교하면서 습관을 다듬어 나가고, 나쁜 코드를 고치는 연습을 해야겠다. 그리고 초반뿐만 아니라 꾸준히 클린 코드를 유지해야 한다는 말도 명심하자.

### 새롭게 배운 개념

- [킬러 앱](https://ko.wikipedia.org/wiki/%ED%82%AC%EB%9F%AC_%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98): 인기와 수요가 높은 응용 프로그램 제품

- 르발랑의 법칙: 나중은 절대 돌아지 않는다는 법칙
- SRP(Single Responsibility Principle): 클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다.
- OCP(Open CLosed Principle): 클래스는 확장에 열려 있어야 하며 변경에 닫혀 있어야 한다.
- LSP(Liskov Substitution Principle): 상속받은 클래스는 기초 클래스를 대체할 수 있어야 한다.
- DIP(Dependency Inversion Principle): 추상화에 의존해야 하며, 구체화에 의존하면 안 된다.
- ISP(Interface Sepgregation Principle): 클라이언트에 밀접하게 작게 쪼개진 인터페이스를 유지한다.

---

[↩️ Go Back](https://github.com/lisy0123/Nomadcoders)

